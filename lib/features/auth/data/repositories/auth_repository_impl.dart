import 'package:dartz/dartz.dart';
import 'package:dio/dio.dart';
import 'package:injectable/injectable.dart';
import '../../../../core/error/failures.dart';
import '../../../../core/storage/storage_strategy.dart';
import '../../../../core/services/logger_service.dart';
import '../../../../core/constants/app_constants.dart';
import '../../domain/entities/user_entity.dart';
import '../../domain/entities/auth_token_entity.dart';
import '../../domain/repositories/auth_repository.dart';
import '../datasources/auth_api_service.dart';
import '../models/auth_request_models.dart';
import '../models/auth_response_models.dart';

@LazySingleton(as: AuthRepository)
class AuthRepositoryImpl implements AuthRepository {
  final AuthApiService _apiService;
  final StorageManager _storageManager;
  final LoggerService _logger;

  AuthRepositoryImpl(this._apiService, this._storageManager, this._logger);

  @override
  Future<Either<Failure, AuthTokenEntity>> login({
    required String email,
    required String password,
    bool rememberMe = false,
  }) async {
    try {
      _logger.info('üîê Attempting login for: $email');

      final request = LoginRequestModel(email: email, password: password);

      final response = await _apiService.login(request);

      if (response.success && response.token != null && response.user != null) {
        // Create token entity from string token
        final tokenEntity = AuthTokenEntity(
          accessToken: response.token!,
          refreshToken: '', // ServiceLabs doesn't provide refresh token
          tokenType: 'Bearer',
          expiresIn: 86400, // 24 hours default
          issuedAt: DateTime.now(),
        );

        final userEntity = response.user!.toEntity();

        // Store auth data securely
        await _storageManager.storeAuthToken(tokenEntity.accessToken);
        await _storageManager.storeUserData(_userEntityToMap(userEntity));

        _logger.info('‚úÖ Login successful');
        return Right(tokenEntity);
      } else {
        final errorMessage =
            response.message.isNotEmpty ? response.message : 'Giri≈ü yapƒ±lamadƒ±';
        _logger.error('‚ùå Login failed: $errorMessage');
        return Left(AuthFailure(errorMessage));
      }
    } on DioException catch (e) {
      _logger.error('‚ùå Login network error', e);
      return Left(_handleDioError(e));
    } catch (e) {
      _logger.error('‚ùå Login unexpected error', e);
      return Left(
        UnknownFailure('Beklenmeyen bir hata olu≈ütu: ${e.toString()}'),
      );
    }
  }

  @override
  Future<Either<Failure, AuthTokenEntity>> register({
    required String name,
    required String email,
    required String password,
    required String passwordConfirmation,
  }) async {
    try {
      _logger.info('üìù Attempting registration for: $email');

      final request = RegisterRequestModel(
        name: name,
        email: email,
        password: password,
        passwordConfirmation: passwordConfirmation,
      );

      final response = await _apiService.register(request);

      // Handle ServiceLabs API response format
      if (response.success && response.token != null && response.user != null) {
        // Create token entity from string token
        final tokenEntity = AuthTokenEntity(
          accessToken: response.token!,
          refreshToken: '', // ServiceLabs doesn't provide refresh token
          tokenType: 'Bearer',
          expiresIn: 86400, // 24 hours default
          issuedAt: DateTime.now(),
        );

        final userEntity = response.user!.toEntity();

        // Store auth data securely
        await _storageManager.storeAuthToken(tokenEntity.accessToken);
        await _storageManager.storeUserData(_userEntityToMap(userEntity));

        _logger.info('‚úÖ Registration successful');
        return Right(tokenEntity);
      } else {
        // Extract error message from ServiceLabs API response
        final errorMessage = response.message;
        final apiErrorCode = response.errorCode;

        if (apiErrorCode.isNotEmpty) {
          final failure = _handleServiceLabsApiError(
            apiErrorCode,
            errorMessage,
            400,
          );
          _logger.error('‚ùå Registration failed: ${failure.message}');
          return Left(failure);
        }

        // Generic error
        final failure = AuthFailure(
          errorMessage.isNotEmpty ? errorMessage : 'Kayƒ±t olu≈üturulamadƒ±',
        );
        _logger.error('‚ùå Registration failed: ${failure.message}');
        return Left(failure);
      }
    } on DioException catch (e) {
      _logger.error('‚ùå Registration network error', e);
      return Left(_handleDioError(e));
    } catch (e) {
      _logger.error('‚ùå Registration unexpected error', e);
      return Left(
        UnknownFailure('Beklenmeyen bir hata olu≈ütu: ${e.toString()}'),
      );
    }
  }

  @override
  Future<Either<Failure, void>> logout() async {
    try {
      _logger.info('üëã Attempting logout');

      final token = await _storageManager.getAuthToken();
      if (token != null) {
        try {
          await _apiService.logout('${AppConstants.bearerPrefix}$token');
        } catch (e) {
          // Even if API logout fails, we should clear local data
          _logger.warning(
            '‚ö†Ô∏è API logout failed, clearing local data anyway',
            e,
          );
        }
      }

      // Clear all auth data from local storage
      await _storageManager.clearAuthData();

      _logger.info('‚úÖ Logout successful');
      return const Right(null);
    } catch (e) {
      _logger.error('‚ùå Logout error', e);
      // Even on error, try to clear local data
      try {
        await _storageManager.clearAuthData();
      } catch (clearError) {
        _logger.error('‚ùå Failed to clear auth data', clearError);
      }
      return Left(
        UnknownFailure('√áƒ±kƒ±≈ü yapƒ±lƒ±rken hata olu≈ütu: ${e.toString()}'),
      );
    }
  }

  @override
  Future<Either<Failure, AuthTokenEntity>> refreshToken() async {
    try {
      _logger.info('üîÑ Refreshing token');

      final refreshToken = await _storageManager.retrieve<String>(
        'refresh_token',
      );
      if (refreshToken == null) {
        return const Left(AuthFailure('Refresh token bulunamadƒ±'));
      }

      final request = RefreshTokenRequestModel(refreshToken: refreshToken);
      final response = await _apiService.refreshToken(request);

      if (response.success && response.token != null) {
        // Create token entity from string token
        final tokenEntity = AuthTokenEntity(
          accessToken: response.token!,
          refreshToken: '', // ServiceLabs doesn't provide refresh token
          tokenType: 'Bearer',
          expiresIn: 86400, // 24 hours default
          issuedAt: DateTime.now(),
        );

        // Update stored tokens
        await _storageManager.storeAuthToken(tokenEntity.accessToken);

        // Update user data if provided
        if (response.user != null) {
          final userEntity = response.user!.toEntity();
          await _storageManager.storeUserData(_userEntityToMap(userEntity));
        }

        _logger.info('‚úÖ Token refresh successful');
        return Right(tokenEntity);
      } else {
        _logger.error('‚ùå Token refresh failed: ${response.message}');
        return Left(AuthFailure(response.message));
      }
    } on DioException catch (e) {
      _logger.error('‚ùå Token refresh network error', e);
      return Left(_handleDioError(e));
    } catch (e) {
      _logger.error('‚ùå Token refresh unexpected error', e);
      return Left(
        UnknownFailure('Token yenilenirken hata olu≈ütu: ${e.toString()}'),
      );
    }
  }

  @override
  Future<Either<Failure, String>> forgotPassword(String email) async {
    try {
      _logger.info('üìß Sending forgot password email to: $email');

      final request = ForgotPasswordRequestModel(email: email);
      final response = await _apiService.forgotPassword(request);

      if (response.success) {
        _logger.info('‚úÖ Forgot password email sent');
        return Right(response.message);
      } else {
        _logger.error('‚ùå Forgot password failed: ${response.message}');
        return Left(ServerFailure(response.message));
      }
    } on DioException catch (e) {
      _logger.error('‚ùå Forgot password network error', e);
      return Left(_handleDioError(e));
    } catch (e) {
      _logger.error('‚ùå Forgot password unexpected error', e);
      return Left(
        UnknownFailure('≈ûifre sƒ±fƒ±rlama isteƒüi g√∂nderilirken hata olu≈ütu'),
      );
    }
  }

  @override
  Future<Either<Failure, String>> resetPassword({
    required String email,
    required String token,
    required String password,
    required String passwordConfirmation,
  }) async {
    try {
      _logger.info('üîë Resetting password for: $email');

      final request = ResetPasswordRequestModel(
        email: email,
        token: token,
        password: password,
        passwordConfirmation: passwordConfirmation,
      );

      final response = await _apiService.resetPassword(request);

      if (response.success) {
        _logger.info('‚úÖ Password reset successful');
        return Right(response.message);
      } else {
        _logger.error('‚ùå Password reset failed: ${response.message}');
        return Left(ServerFailure(response.message));
      }
    } on DioException catch (e) {
      _logger.error('‚ùå Password reset network error', e);
      return Left(_handleDioError(e));
    } catch (e) {
      _logger.error('‚ùå Password reset unexpected error', e);
      return Left(UnknownFailure('≈ûifre sƒ±fƒ±rlanƒ±rken hata olu≈ütu'));
    }
  }

  @override
  Future<Either<Failure, UserEntity>> getUserProfile() async {
    try {
      _logger.info('üë§ Getting user profile');

      final token = await _storageManager.getAuthToken();
      if (token == null) {
        return const Left(AuthFailure('Oturum ge√ßersiz'));
      }

      final response = await _apiService.getProfile(
        '${AppConstants.bearerPrefix}$token',
      );
      final userEntity = response.toEntity();

      // Update cached user data
      await _storageManager.storeUserData(_userEntityToMap(userEntity));

      _logger.info('‚úÖ User profile retrieved');
      return Right(userEntity);
    } on DioException catch (e) {
      _logger.error('‚ùå Get profile network error', e);
      return Left(_handleDioError(e));
    } catch (e) {
      _logger.error('‚ùå Get profile unexpected error', e);
      return Left(UnknownFailure('Profil bilgileri alƒ±nƒ±rken hata olu≈ütu'));
    }
  }

  @override
  Future<Either<Failure, UserEntity>> updateProfile(
    Map<String, dynamic> profileData,
  ) async {
    try {
      _logger.info('‚úèÔ∏è Updating user profile');

      final token = await _storageManager.getAuthToken();
      if (token == null) {
        return const Left(AuthFailure('Oturum ge√ßersiz'));
      }

      final response = await _apiService.updateProfile(
        '${AppConstants.bearerPrefix}$token',
        profileData,
      );

      final userEntity = response.toEntity();

      // Update cached user data
      await _storageManager.storeUserData(_userEntityToMap(userEntity));

      _logger.info('‚úÖ Profile updated successfully');
      return Right(userEntity);
    } on DioException catch (e) {
      _logger.error('‚ùå Update profile network error', e);
      return Left(_handleDioError(e));
    } catch (e) {
      _logger.error('‚ùå Update profile unexpected error', e);
      return Left(UnknownFailure('Profil g√ºncellenirken hata olu≈ütu'));
    }
  }

  @override
  Future<Either<Failure, String>> verifyEmail(
    Map<String, dynamic> verificationData,
  ) async {
    try {
      _logger.info('üìß Verifying email');

      final response = await _apiService.verifyEmail(verificationData);

      if (response.success) {
        _logger.info('‚úÖ Email verified successfully');
        return Right(response.message);
      } else {
        _logger.error('‚ùå Email verification failed: ${response.message}');
        return Left(ServerFailure(response.message));
      }
    } on DioException catch (e) {
      _logger.error('‚ùå Email verification network error', e);
      return Left(_handleDioError(e));
    } catch (e) {
      _logger.error('‚ùå Email verification unexpected error', e);
      return Left(UnknownFailure('E-posta doƒürulanƒ±rken hata olu≈ütu'));
    }
  }

  @override
  Future<bool> isAuthenticated() async {
    try {
      return await _storageManager.isAuthenticated();
    } catch (e) {
      _logger.error('‚ùå Error checking authentication status', e);
      return false;
    }
  }

  @override
  Future<UserEntity?> getCachedUser() async {
    try {
      final userData = await _storageManager.getUserData();
      if (userData != null) {
        return _mapToUserEntity(userData);
      }
      return null;
    } catch (e) {
      _logger.error('‚ùå Error getting cached user', e);
      return null;
    }
  }

  @override
  Future<void> clearAuthData() async {
    try {
      await _storageManager.clearAuthData();
    } catch (e) {
      _logger.error('‚ùå Error clearing auth data', e);
      rethrow;
    }
  }

  // Helper methods

  Failure _handleDioError(DioException error) {
    _logger.error('üåê Dio error: ${error.type} - ${error.message}');

    switch (error.type) {
      case DioExceptionType.badResponse:
        final statusCode = error.response?.statusCode ?? 0;
        final responseData = error.response?.data;
        final message = _extractErrorMessage(responseData);

        // Handle ServiceLabs API specific error codes
        final apiErrorCode = _extractApiErrorCode(responseData);
        if (apiErrorCode.isNotEmpty) {
          return _handleServiceLabsApiError(apiErrorCode, message, statusCode);
        }

        switch (statusCode) {
          case 400:
            return AuthFailure(
              message.isNotEmpty ? message : 'Ge√ßersiz istek',
              statusCode,
            );
          case 401:
            return AuthFailure(
              message.isNotEmpty ? message : 'Oturum ge√ßersiz',
              statusCode,
            );
          case 422:
            return ValidationFailure(
              message.isNotEmpty ? message : 'Girilen bilgiler ge√ßersiz',
              _extractValidationErrors(responseData),
              statusCode,
            );
          case 500:
            return ServerFailure('Sunucu hatasƒ± olu≈ütu', statusCode);
          default:
            return ServerFailure(
              message.isNotEmpty ? message : 'Sunucu hatasƒ±',
              statusCode,
            );
        }

      case DioExceptionType.cancel:
        return const NetworkFailure('ƒ∞stek iptal edildi');

      case DioExceptionType.connectionError:
        return const NetworkFailure('ƒ∞nternet baƒülantƒ±sƒ± yok');

      case DioExceptionType.connectionTimeout:
        return const NetworkFailure('Baƒülantƒ± zaman a≈üƒ±mƒ±na uƒüradƒ±');

      case DioExceptionType.receiveTimeout:
        return const NetworkFailure('Sunucu yanƒ±t vermedi');

      case DioExceptionType.sendTimeout:
        return const NetworkFailure('ƒ∞stek g√∂nderilemedi');

      default:
        return NetworkFailure('Aƒü hatasƒ±: ${error.message}');
    }
  }

  /// Handle ServiceLabs API specific error codes
  Failure _handleServiceLabsApiError(
    String errorCode,
    String originalMessage,
    int statusCode,
  ) {
    switch (errorCode.toUpperCase()) {
      case 'USER_EXISTS':
        return AuthFailure(
          'Bu email adresi zaten kayƒ±tlƒ±. L√ºtfen farklƒ± bir email kullanƒ±n.',
          statusCode,
        );

      case 'INVALID_EMAIL_FORMAT':
        return ValidationFailure(
          'Ge√ßersiz email formatƒ±. L√ºtfen doƒüru bir email adresi girin.',
          {
            'email': ['Ge√ßersiz email formatƒ±'],
          },
          statusCode,
        );

      case 'INVALID_PASSWORD':
        return ValidationFailure(
          '≈ûifre √ßok kƒ±sa. En az 6 karakter olmalƒ±dƒ±r.',
          {
            'password': ['≈ûifre en az 6 karakter olmalƒ±dƒ±r'],
          },
          statusCode,
        );

      case 'INVALID_NAME':
        return ValidationFailure('Ge√ßersiz isim. En az 2 karakter olmalƒ±dƒ±r.', {
          'name': ['ƒ∞sim en az 2 karakter olmalƒ±dƒ±r'],
        }, statusCode);

      case 'EMAIL_REQUIRED':
        return ValidationFailure('Email adresi gereklidir.', {
          'email': ['Email adresi gereklidir'],
        }, statusCode);

      case 'PASSWORD_REQUIRED':
        return ValidationFailure('≈ûifre gereklidir.', {
          'password': ['≈ûifre gereklidir'],
        }, statusCode);

      case 'NAME_REQUIRED':
        return ValidationFailure('ƒ∞sim gereklidir.', {
          'name': ['ƒ∞sim gereklidir'],
        }, statusCode);

      case 'INVALID_CREDENTIALS':
        return AuthFailure(
          'Email veya ≈üifre hatalƒ±. L√ºtfen bilgilerinizi kontrol edin.',
          statusCode,
        );

      case 'USER_NOT_FOUND':
        return AuthFailure('Kullanƒ±cƒ± bulunamadƒ±.', statusCode);

      case 'TOKEN_EXPIRED':
        return AuthFailure(
          'Oturum s√ºresi doldu. L√ºtfen tekrar giri≈ü yapƒ±n.',
          statusCode,
        );

      case 'INVALID_TOKEN':
        return AuthFailure(
          'Ge√ßersiz oturum. L√ºtfen tekrar giri≈ü yapƒ±n.',
          statusCode,
        );

      default:
        // If we don't recognize the error code, use the original message
        return AuthFailure(
          originalMessage.isNotEmpty
              ? originalMessage
              : 'Bir hata olu≈ütu. L√ºtfen tekrar deneyin.',
          statusCode,
        );
    }
  }

  /// Extract API error code from ServiceLabs response
  String _extractApiErrorCode(dynamic responseData) {
    if (responseData == null) return '';

    // Handle response model objects
    if (responseData is RegisterResponseModel) {
      // Check if there's an error field in the response model
      return responseData.message.isNotEmpty ? responseData.message : '';
    }

    if (responseData is LoginResponseModel) {
      return responseData.message.isNotEmpty ? responseData.message : '';
    }

    // Handle raw response data (Map)
    if (responseData is Map<String, dynamic>) {
      // ServiceLabs API format: {"response": {"code": 400, "message": "USER_EXISTS"}, "data": {}}
      final response = responseData['response'];
      if (response is Map<String, dynamic>) {
        return response['message'] ?? '';
      }

      // Alternative format: {"error": "USER_EXISTS", "message": "..."}
      return responseData['error'] ?? '';
    }

    return '';
  }

  String _extractErrorMessage(dynamic responseData) {
    if (responseData == null) return '';

    // Handle response model objects
    if (responseData is RegisterResponseModel) {
      return responseData.message.isNotEmpty
          ? responseData.message
          : 'Kayƒ±t olu≈üturulamadƒ±';
    }

    if (responseData is LoginResponseModel) {
      return responseData.message.isNotEmpty
          ? responseData.message
          : 'Giri≈ü yapƒ±lamadƒ±';
    }

    // Handle raw response data (Map)
    if (responseData is Map<String, dynamic>) {
      // ServiceLabs API format: {"response": {"code": 400, "message": "USER_EXISTS"}, "data": {}}
      final response = responseData['response'];
      if (response is Map<String, dynamic>) {
        return response['message'] ?? '';
      }

      // Standard format: {"message": "...", "error": "..."}
      return responseData['message'] ?? responseData['error'] ?? '';
    }

    return responseData.toString();
  }

  Map<String, List<String>>? _extractValidationErrors(dynamic responseData) {
    if (responseData == null) return null;

    if (responseData is Map<String, dynamic>) {
      final errors = responseData['errors'];
      if (errors is Map<String, dynamic>) {
        final validationErrors = <String, List<String>>{};
        errors.forEach((key, value) {
          if (value is List) {
            validationErrors[key] = value.map((e) => e.toString()).toList();
          } else {
            validationErrors[key] = [value.toString()];
          }
        });
        return validationErrors;
      }
    }

    return null;
  }

  Map<String, dynamic> _userEntityToMap(UserEntity user) {
    return {
      'id': user.id,
      'name': user.name,
      'email': user.email,
      'phone_number': user.phoneNumber,
      'profile_image_url': user.profileImageUrl,
      'email_verified_at': user.emailVerifiedAt?.toIso8601String(),
      'created_at': user.createdAt.toIso8601String(),
      'updated_at': user.updatedAt.toIso8601String(),
    };
  }

  UserEntity _mapToUserEntity(Map<String, dynamic> userData) {
    return UserEntity(
      id: userData['id'] ?? '',
      name: userData['name'] ?? '',
      email: userData['email'] ?? '',
      phoneNumber: userData['phone_number'],
      profileImageUrl: userData['profile_image_url'],
      emailVerifiedAt:
          userData['email_verified_at'] != null
              ? DateTime.tryParse(userData['email_verified_at'])
              : null,
      createdAt: DateTime.parse(
        userData['created_at'] ?? DateTime.now().toIso8601String(),
      ),
      updatedAt: DateTime.parse(
        userData['updated_at'] ?? DateTime.now().toIso8601String(),
      ),
    );
  }
}
